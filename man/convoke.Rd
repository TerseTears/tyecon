% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dsl.R
\name{convoke}
\alias{convoke}
\title{Unify functions interfaces}
\usage{
convoke(...)
}
\arguments{
\item{...}{First element is the desired unifying interface. Remaining
elements are all the various specifications for function argument
transformations.}
}
\value{
Function with additional class \emph{convoke} with arguments being\preformatted{convoke_func(specified_args, interface, evaluate = TRUE, ...)
}

The \code{evaluate}
argument is useful for debugging purposes. Extra arguments can be passed in
the format \code{interface.arg}.
}
\description{
\code{convoke} unifies functions along a single specification using
statements on function argument transformations that would be needed. The
result is a single function whose \emph{interface} can be changed simply by
changing the respective argument in the generated function.
}
\section{Unifying Functions}{
\subsection{Specifying the unifying interface}{

The unifying interface needs to be specified in the format\preformatted{..(arg1 = default1, arg2 = default2, etc.)
}

Where the \code{..} prefix and parentheses are required and an error is
thrown otherwise. The equality sign in arguments specifications is also
necessary. Simply omit the default value on the RHS if not needed.
}

\subsection{Specifying function argument transformations}{

Transformations follow the formula format\preformatted{func1(func1arg1 = transformed_arg1, func1arg2 = transformed_arg2) ~
postprocess(result)
}

Essentially, pass the function as if it is to take
arguments from the unified function.
\subsection{Postprocessing function}{

The postprocess function on the right of the formula specifies what
postprocessing is required on the result of applying \code{func1}. It is to be
specified similarly to how functions in \code{purrr::map} are specified (that is
by the \code{.} and \code{.x} syntax.
}

}
}

\section{Composing functions}{
It is also possible to progressively add functions to a convoke function
simply by adding to the convoke function the new specifications:\preformatted{convoke_func + (func_spec ~ postfunc)
}
}

\examples{
# unifying functions with swapped arguments
foo <- function(a1, b1) { a1/b1 }
bar <- function(b2, a2) { a2/b2 }
convoked <- convoke(..(..a = , ..b = ),
                   foo(a1 = ..a, b1 = ..b) ~ .,
                   bar(b2 = ..b, a2 = ..a) ~ .)
c(convoked(9,5), bar(5,9))
c(convoked(9,5,interface="bar"), foo(9,5))

# supplying optional arguments
foo <- function(a1, b1, round=FALSE) { if(round) round(a1/b1) else a1/b1 }
bar <- function(b2, a2) { a2/b2 }
convoked <- convoke(..(..a = , ..b = ),
                   foo(a1 = ..a, b1 = ..b) ~ .,
                   bar(b2 = ..b, a2 = ..a) ~ .)
c(convoked(9,5, foo.round=FALSE), bar(5,9))
c(convoked(9,5, foo.round=TRUE), round(bar(5,9)))

# post-processing specification
foo <- function(a1, b1) { a1/b1 }
bar <- function(b2, a2) { a2/b2 }
multfactor <- 2
convoked <- convoke(..(..a = , ..b = ), 
                   foo(a1 = ..a, b1 = ..b) ~ .*multfactor,
                   bar(b2 = ..b, a2 = ..a) ~ .*multfactor)
c(convoked(9,5), bar(5,9)*multfactor)
multfunc <- function(x) x*2
convoked <- convoke(..(..a = , ..b = ), 
                   foo(a1 = ..a, b1 = ..b) ~ multfunc(.),
                   bar(b2 = ..b, a2 = ..a) ~ multfunc(.))
c(convoked(9,5), bar(5,9)*multfactor)

# adding further functions later
foo <- function(a1, b1) { a1/b1 }
bar <- function(b2, a2) { a2/b2 }
baz <- function(a3, b3) { a3/b3 }
(convoked <- convoke(..(..a = , ..b = ), foo(a1 = ..a, b1 = ..b) ~ .))
(convoked <- convoked + (bar(b2 = ..b, a2 = ..a) ~ .) +
    (baz(a3 = ..a, b3 = ..b) ~ .))
c(convoked(9,5, interface="baz"), bar(5,9))
}
