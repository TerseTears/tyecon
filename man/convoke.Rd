% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/convoke.R
\name{convoke}
\alias{convoke}
\title{Unify function interfaces}
\usage{
convoke(argslist, ...)
}
\arguments{
\item{argslist}{[\code{list}] The desired unifying arguments. A list call.}

\item{...}{[\code{function}] All the various specifications for function argument
transformations.}
}
\value{
Function with additional class \emph{convoke} with arguments being

\if{html}{\out{<div class="sourceCode r">}}\preformatted{convoke_func(specified_args, interface, ..., evaluate = TRUE)
}\if{html}{\out{</div>}}

The \code{evaluate} argument is useful for debugging purposes. Extra arguments can
be passed in the format \code{interface.arg}.
}
\description{
\code{convoke} unifies functions along a single specification using
statements on function argument transformations that would be needed. The
result is a single function whose \emph{interface} can be changed simply by
changing the respective argument in the generated function.
}
\section{Unifying Functions}{
\subsection{Specifying the unifying interface}{

The unifying interface needs to be specified as arglist for the new function

\if{html}{\out{<div class="sourceCode r">}}\preformatted{list(arg1 = default1, arg2 = default2, etc.)
}\if{html}{\out{</div>}}
}

\subsection{Specifying function argument transformations}{

Transformations follows the function specification format

\if{html}{\out{<div class="sourceCode r">}}\preformatted{func1(func1arg1 = transformed_arg1, func1arg2 = transformed_arg2)
}\if{html}{\out{</div>}}

Essentially, pass the function as if it is to take
arguments from the unified function.
}
}

\section{Composing functions}{
It is also possible to progressively add functions to a convoke function
simply by adding to the convoke function the new specifications:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{convoke_func + ~func_spec
}\if{html}{\out{</div>}}
}

\examples{
# unifying functions with swapped arguments
foo <- function(a1, b1) {
  a1 / b1
}
bar <- function(b2, a2) {
  a2 / b2
}
convoked <- convoke(
  list(a, b),
  foo(a1 = a, b1 = b),
  bar(b2 = b, a2 = a)
)
c(convoked(9, 5), bar(5, 9))
c(convoked(9, 5, interface = "bar"), foo(9, 5))

# supplying optional arguments
foo <- function(a1, b1, round = FALSE) {
  if (round) round(a1 / b1) else a1 / b1
}
bar <- function(b2, a2) {
  a2 / b2
}
convoked <- convoke(
  list(a, b),
  foo(a1 = a, b1 = b),
  bar(b2 = b, a2 = a)
)
c(convoked(9, 5, foo.round = FALSE), bar(5, 9))
c(convoked(9, 5, foo.round = TRUE), round(bar(5, 9)))

# TODO fix and show this for three sequences
# adding further functions later
foo <- function(a1, b1) {
  a1 / b1
}
bar <- function(b2, a2) {
  a2 / b2
}
(convoked <- convoke(list(a, b), foo(a1 = a, b1 = b)))
(convoked <- convoked + ~ bar(b2 = b, a2 = a))
c(convoked(9, 5, interface = "bar"), foo(5, 9))
}
\seealso{
Other function assemblers: 
\code{\link{conflate}()}
}
\concept{function assemblers}
