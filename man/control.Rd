% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/control.R
\name{control}
\alias{control}
\title{Evaluate expression over multiple values}
\usage{
control(
  code,
  ...,
  .refiner = identity,
  .prober,
  .selector = identity,
  .unnest_value = FALSE,
  .unnest_summary = FALSE
)
}
\arguments{
\item{code}{[\code{expr}] Expression to be evaluated.}

\item{...}{[\verb{argument value pairs}] Variables in \code{code} with the multiple
values assigned to them.}

\item{.refiner}{[\code{function}] Preprocessing the value tree over which
evaluation of \code{code} is to be performed. Takes the tree \code{tibble} as input.}

\item{.prober}{[\code{function}] Extracting extra information from the results
of evaluating \code{code}. Takes the list of such values as input.}

\item{.selector}{[\code{function}] Modifying the final \code{tibble} or extracting
what's needed from it. Takes the refined, evaluated, probed \code{tibble} as
input.}

\item{.unnest_value}{[\code{boolean}] Whether to unnest the results inside the
\code{tibble}.}

\item{.unnest_summary}{[\code{boolean}] Whether to unnest the results from
\code{.prober} inside the \code{tibble}.}
}
\value{
A \code{tibble} with information on the evaluation \code{tree}, and the
columns \code{.value}, and \code{.summary} if probed and not unnested.
}
\description{
\code{control} allows specifying multiple values for variables in an expression,
returning all results in a \code{tibble}.
}
\examples{
set.seed(123)
# Use control to apply multiple arguments to the same expression
control(
  {
    lm(Sepal.Length ~ ., data = rsample::analysis(fold$splits))
  },
  fold = purrr::transpose(rsample::vfold_cv(iris, 5))
)

# Use .selector to alter output
control(
  {
    lm(Sepal.Length ~ ., data = rsample::analysis(fold$splits))
  },
  fold = purrr::transpose(rsample::vfold_cv(iris, 5)),
  .selector = ~ tidyr::unnest_wider(., fold, strict = TRUE)
)

# Use .prober to extract information from results
control(
  {
    lm(Sepal.Length ~ ., data = rsample::analysis(fold$splits))
  },
  fold = purrr::transpose(rsample::vfold_cv(iris, 5)),
  .prober = ~ summary(.)$r.squared
)

# Use list() and unnest_value to return multiple results
control(
  {
    model <- lm(Sepal.Length ~ ., data = rsample::analysis(fold$splits))
    holdout <- rsample::assessment(fold$splits)
    holdout$.fit <- predict(model, holdout)
    rmse_value <- yardstick::rmse(holdout, Sepal.Length, .fit)
    list(model = model, rmse = rmse_value)
  },
  fold = purrr::transpose(rsample::vfold_cv(iris, 5)),
  .unnest_value = TRUE
)

# Use multiple levels with the formula syntax
control(
  {
    model <- earth::earth(
      Sepal.Length ~ ., rsample::analysis(fold$splits), degree = degree)
    holdout <- rsample::assessment(fold$splits)
    holdout$.fit <- predict(model, holdout, "response")[, 1]
    rmse_value <- yardstick::rmse(holdout, Sepal.Length, .fit)
    list(model = model, rmse = rmse_value)
  },
  fold = purrr::transpose(rsample::vfold_cv(iris, 3)) ~ 1,
  degree = 1:5 ~ 2,
  .unnest_value = TRUE,
  .selector = ~ dplyr::group_by(., degree) \%>\%
    dplyr::summarise(
      model = list(dplyr::first(model)),
      rmse = mean(rmse$.estimate)
    )
)

# Example with tuning a ridge model
control(
  {
    keepin <- rsample::analysis(fold$splits)
    model <- elasticnet::enet(
      Sepal.Length ~ .,
      x = model.matrix(Sepal.Length ~ . - 1, keepin),
      y = keepin[["Sepal.Length"]],
      lambda = lambda
    )
    holdout <- rsample::assessment(fold$splits)
    holdout$.fit <- predict(
      model,
      model.matrix(Sepal.Length ~ . - 1, holdout),
      s = 1, mode = "fraction"
    )$fit
    rmse_value <- yardstick::rmse(holdout, Sepal.Length, .fit)
    list(model = model, rmse = rmse_value)
  },
  fold = purrr::transpose(rsample::vfold_cv(iris, 5)) ~ 1,
  lambda = seq(0, 0.1, 0.01) ~ 2,
  .unnest_value = TRUE,
  .selector = ~ dplyr::group_by(., lambda) \%>\%
    dplyr::summarise(
      model = list(dplyr::first(model)),
      rmse = mean(rmse$.estimate)
    )
)
}
\seealso{
Other result assemblers: 
\code{\link{\%$>\%}()},
\code{\link{\%->\%}()},
\code{\link{\%<-\%}()},
\code{\link{\%to\%}()},
\code{\link{conserve}()}
}
\concept{result assemblers}
