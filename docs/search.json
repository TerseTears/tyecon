[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2021 tyecon authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/compare-tidymodes.html","id":"fitting-models-without-parsnip","dir":"Articles","previous_headings":"","what":"Fitting Models Without parsnip","title":"Fitting Models *Without* parsnip","text":"vignette shows can achieve (better) consistency using multiple models together without need packages parsnip broom. Original article uses two packages can found tidymodels book, .","code":""},{"path":"/articles/compare-tidymodes.html","id":"the-linear-functions-family","dir":"Articles","previous_headings":"Fitting Models Without parsnip","what":"The linear functions family","title":"Fitting Models *Without* parsnip","text":"build family, simply encapsulate three lm, stan_glm, glmnet functions together, using tyecon::convoke: First, unify models: Now ’d want see coefficients, possibly alongside information. fact, may want know lot model well. can also store tidy variant: can also plot results rather easily. First, let us make unified plot function using conflate, plot simply generic function:","code":"library(rstanarm) library(glmnet) ames_split <- initial_split(ames, prop = 0.80) ames_train <- training(ames_split) (linear_model <-   convoke(     list(formula, data),     lm(formula = formula, data = data),     stan_glm(formula = formula, data = data, mean_PPD = FALSE),     glmnet(       x = model.frame(formula, data = data)[-1],       y = model.frame(formula, data = data)[[1]]     )   )) #> convoke function #>   interfaces: lm(), stan_glm(), glmnet() #>   args: formula, data, interface = lm, interface.args model_results <- enframe(   map(     set_names(names(linear_model)),     ~ linear_model(Sale_Price ~ Longitude + Latitude, ames_train, interface = .)   ),   \"modelname\", \"model\" ) %>% rowwise() (model_results <- mutate(model_results,   vcov_val = list(possibly(vcov, NULL)(model)) )) #> # A tibble: 3 × 3 #> # Rowwise:  #>   modelname model     vcov_val      #>   <chr>     <list>    <list>        #> 1 lm        <lm>      <dbl [3 × 3]> #> 2 stan_glm  <stanreg> <dbl [3 × 3]> #> 3 glmnet    <elnet>   <NULL> (model_results <- mutate(model_results,   coef_val = list(possibly(coef, NULL)(model)) )) #> # A tibble: 3 × 4 #> # Rowwise:  #>   modelname model     vcov_val      coef_val        #>   <chr>     <list>    <list>        <list>          #> 1 lm        <lm>      <dbl [3 × 3]> <dbl [3]>       #> 2 stan_glm  <stanreg> <dbl [3 × 3]> <dbl [3]>       #> 3 glmnet    <elnet>   <NULL>        <dgCMatrx[,56]> (model_results <- mutate(model_results,   tidy_val = list(possibly(tidy, NULL)(model)) )) #> # A tibble: 3 × 5 #> # Rowwise:  #>   modelname model     vcov_val      coef_val        tidy_val           #>   <chr>     <list>    <list>        <list>          <list>             #> 1 lm        <lm>      <dbl [3 × 3]> <dbl [3]>       <tibble [3 × 5]>   #> 2 stan_glm  <stanreg> <dbl [3 × 3]> <dbl [3]>       <tibble [3 × 3]>   #> 3 glmnet    <elnet>   <NULL>        <dgCMatrx[,56]> <tibble [165 × 5]> (conflated_plot <- conflate(plot(x))) #> conflate function for plot #>  args: x, object.args par(mfrow = c(2, 2)) walk(   pull(model_results, model),   ~ conflated_plot(.,     lm.ask = FALSE, lm.which = 1,     elnet.xvar = \"dev\", stanreg.plotfun = \"hist\"   ) )"},{"path":"/articles/example-issues.html","id":"the-convoke-function","dir":"Articles","previous_headings":"","what":"The convoke Function","title":"Example Issues","text":"one example different function interfaces thing provided DSL simplify issue. two functions take different data type , produce different data, use different name trim argument, one default value column (works vectors). Three vastly different APIs. Now, unification: One can also add additional specifications later: Nevertheless, ultimate goal specify DSL package author can convert functions unified interface specifying general rules (text file bundled package instance). allow package author separate need conform unified interface writing packages however seen best. Nevertheless, hard-codded values can’t changed passed obviously, still require upstream fixes.","code":"basemeancalc <- function(listdata, trimmed = 0.0, na.rm = T) {   mean(listdata, trim = trimmed, na.rm = na.rm) }  tidymeancalc <- function(tibbledata, column, trimend = 0.0, trimstart = 0.0) {   column <- as_string(ensym(column))   colvector <- tibbledata[[column]] %>%     sort() %>%     na.omit()   nelem <- length(colvector)   colvector <-     colvector[floor(nelem * trimstart) + 1:nelem - floor(nelem * trimend)]   return(mean(colvector)) }  mydf <- tribble(   ~x, ~y,   1, 5,   4, 3,   6, 2,   17, 4,   8, 12,   14, 16,   21, 72,   19, 32,   10, 15,   NA, NA )  tidymeancalc(mydf, x, trimend = 0.1, trimstart = 0.1) #> [1] 11.11111 basemeancalc(mydf$x, trimmed = 0.1) #> [1] 11.11111 mean(mydf$x, trim = 0.1, na.rm = T) #> [1] 11.11111 (mymean <- convoke(   list(tibble, column, trim),   basemeancalc(listdata = tibble[[column]], trimmed = trim),   tidymeancalc(     tibbledata = tibble, column = !!column, trimend = trim, trimstart = trim   ) )) #> convoke function #>   interfaces: basemeancalc(), tidymeancalc() #>   args: tibble, column, trim, interface = basemeancalc, interface.args map(   set_names(c(\"basemeancalc\", \"tidymeancalc\")),   ~ mymean(mydf, \"x\", 0.1, interface = ., basemeancalc.na.rm = T) ) #> $basemeancalc #> [1] 11.11111 #>  #> $tidymeancalc #> [1] 11.11111 mymean <- mymean + ~ mean(x = tibble[[column]], trimmed = trim) mymean(mydf, \"x\", 0.1, interface = \"mean\", mean.na.rm = T) #> [1] 11.11111"},{"path":"/articles/example-issues.html","id":"the---pipem-operator","dir":"Articles","previous_headings":"","what":"The %->% pipem Operator","title":"Example Issues","text":"operator facilitates chaining instructions without explicitly writing magrittr pipe. Additionally, allows intermediate values kept used later chain instructions. instance, consider case want compute abs(vec^3) * (sum(vec^2) + 1) sequentially, instead using single function: Another convenience operator one can simply comment remaining lines debugging purposes, without write extra identity() instance. Note since operator treats symbols specially, functions single arguments form func() just func. best practice original magrittr pipe well case.","code":"c(-4, 9, -3, 12) %->% {   (function(x) {     x^2   })()   vec2 <- .   (function(x) {     abs(x^3) + sum(vec2) + 1   })() } #> [1]    4347  531692     980 2986235"},{"path":"/articles/example-issues.html","id":"the-to-operator","dir":"Articles","previous_headings":"","what":"The %to% Operator","title":"Example Issues","text":"operator facilitates different issue arises quite often model building. requiring multiple results object. Example: instance, can know p-values now: Comparing result broom::glance, one can see approach much flexible.","code":"modelfit <- lm(y ~ x, data = mydf) (res <- summary(modelfit) %to% {   rsquared ~ .$r.squared   adjrsquared ~ .$adj.r.squared   residuals ~ .$residuals   pval ~ coef(.)[, \"Pr(>|t|)\"]   termsof ~ .$terms   callof ~ .$call }) #> # A tibble: 1 × 6 #>   rsquared adjrsquared residuals pval      termsof   callof     #>      <dbl>       <dbl> <I<list>> <I<list>> <I<list>> <I<list>>  #> 1    0.512       0.443 <dbl [9]> <dbl [2]> <terms>   <language> res$pval #> [[1]] #> (Intercept)           x  #>  0.51285227  0.03011035"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"TerseTears. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"TerseTears (2022). tyecon: Assemble functions results ease. R package version 0.2.3, https://tersetears.github.io/tyecon/.","code":"@Manual{,   title = {tyecon: Assemble functions and results with ease},   author = {{TerseTears}},   year = {2022},   note = {R package version 0.2.3},   url = {https://tersetears.github.io/tyecon/}, }"},{"path":"/index.html","id":"tyecon-","dir":"","previous_headings":"","what":"Assemble functions and results with ease","title":"Assemble functions and results with ease","text":"package make assembling functions results easier quicker.","code":""},{"path":"/index.html","id":"main-idea","dir":"","previous_headings":"","what":"Main Idea","title":"Assemble functions and results with ease","text":"tyecon package set macros allow conciser code using functions objects different packages together. essentially two existing approaches dealing differences package interfaces: 1. Employing sort object-oriented approach use generic functions 2. Writing meta packages unify interfaces. tyecon package proposes data/code alternative: Utilizing meta functions simple DSL user can take care tasks . allows greater flexibility yet avoids disparity comes differing shapes package models, plots, etc. also eliminating need meta-packages (simplifying writing ).","code":""},{"path":[]},{"path":"/index.html","id":"convoke","dir":"","previous_headings":"The Macros","what":"convoke","title":"Assemble functions and results with ease","text":"Unifies function interfaces. Consider two functions swapped arguments want use together without extra hassle. want able simply change “interface” single argument:","code":"foo <- function(a1, b1) {   a1 / b1 } bar <- function(b2, a2) {   a2 / b2 } foobar <- convoke(   # First argument is the list of shared arguments.   list(a, b),   # Following arguments are the translation of the    # shared arguments to the # function interfaces.   foo(a1 = a, b1 = b),   bar(b2 = b, a2 = a) ) # This allows using the two functions in a map with minimal hassle. purrr::map_dfr(   rlang::set_names(c(\"foo\", \"bar\")),   ~ foobar(3, 9, interface = .) )"},{"path":"/index.html","id":"conflate","dir":"","previous_headings":"The Macros","what":"conflate","title":"Assemble functions and results with ease","text":"Unifies generic function interfaces. Another issue one tries use dissimilar generic methods together, yet method comes peripheral arguments. conflate function allows one supply arguments together:","code":"lm_model <- lm(Sepal.Length ~ Sepal.Width, data = iris) glm_model <- glm(Sepal.Length ~ Sepal.Width, data = iris)  summary_lm_glm <- conflate(summary(x, correlation = TRUE))  purrr::map(   list(lm_model, glm_model),   ~ summary_lm_glm(., lm.symbolic.cor = TRUE) )"},{"path":"/index.html","id":"--convey-operator","dir":"","previous_headings":"The Macros","what":"%->% convey operator","title":"Assemble functions and results with ease","text":"Passes data created step next function. Transforming data can require passing consecutively multiple functions. Nevertheless, intermediate results may need kept later stages. single context thus requires macro:","code":"df <- tibble::tribble(   ~x, ~y,   1, 2,   5, 9,   12, 8 ) # Apply multiple functions to the data without specifying extraneous pipes. df %->% {   dplyr::mutate(x2 = x^2)   dplyr::mutate(x3 = x^3)   # Keep intermediate values in the context of the data for use at later stages.   colx2 <- x2   dplyr::mutate(x4 = x2^2)   dplyr::mutate(x6 = (colx2)^3) }"},{"path":"/index.html","id":"-construct-operator","dir":"","previous_headings":"The Macros","what":"%$>% construct operator","title":"Assemble functions and results with ease","text":"pipe facilitates transforming data new structure concise syntax also enforcing “bottom-” approach:","code":"df <- tibble::tribble(   ~x, ~y,   1, 2,   5, 9,   12, 8 ) df %$>% {   # Each assignment is kept as the named element of a final list   minx <- min(x)   miny <- min(y)   # Assignments are in context and thus can be used for the construction   # of later elements.   minxy <- min(minx, miny) }"},{"path":"/index.html","id":"other-macros-to-come","dir":"","previous_headings":"The Macros","what":"Other macros to come","title":"Assemble functions and results with ease","text":"’m experimenting R workflow trying optimize process mingling different parts concisely thus macros come. suggestions please open issue.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Assemble functions and results with ease","text":"package still long way go. want try , instruction: uninstall package, run usual remove.packages command.","code":"# Install remotes package if not installed. install.packages(\"remotes\") # Install tyecon using the remotes package. remotes::install_github(\"TerseTears/tyecon\")"},{"path":"/index.html","id":"name","dir":"","previous_headings":"","what":"Name","title":"Assemble functions and results with ease","text":"idea package originally straighten tasks common econometrics, hence “tidy econometrics”” (abbreviations didn’t look good). Still, realized early problems common general data analysis tasks, yet name remained. Now, can considered “tidy con” functions, functions simplify joint operations conciser statements.","code":""},{"path":"/index.html","id":"pending-tasks","dir":"","previous_headings":"","what":"Pending Tasks","title":"Assemble functions and results with ease","text":"Better error handling Writing vignette explaining possible uses package developemnt Writing tests conflate (QoL) allowing supplying custom arguments c(), e.g. stan_glm   = c(chains=5, iter=500).","code":""},{"path":"/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Assemble functions and results with ease","text":"MIT","code":""},{"path":"/reference/conflate.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine generic method interfaces — conflate","title":"Combine generic method interfaces — conflate","text":"conflate combines methods S3 standard generic allowing arguments various methods specified single function returns.","code":""},{"path":"/reference/conflate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine generic method interfaces — conflate","text":"","code":"conflate(generic_spec)"},{"path":"/reference/conflate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine generic method interfaces — conflate","text":"generic_spec [call] Generic function applied arguments shared methods combined.","code":""},{"path":"/reference/conflate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine generic method interfaces — conflate","text":"Function additional class conflate arguments ... specifies additional arguments supplied form object_class.arg. evaluate argument useful debugging purposes.","code":"conflate_func(generic_spec_args, ..., evaluate = TRUE)"},{"path":"/reference/conflate.html","id":"combining-methods","dir":"Reference","previous_headings":"","what":"Combining Methods","title":"Combine generic method interfaces — conflate","text":"generic_spec argument generic function applied shared arguments methods combined. decided, additional arguments passed generated function need form object_class.arg arguments unique method dispatched object class.","code":""},{"path":[]},{"path":"/reference/conflate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine generic method interfaces — conflate","text":"","code":"# first construct two models glm.model <- glm(Sepal.Length ~ Sepal.Width, data = iris) lm.model <- lm(Sepal.Length ~ Sepal.Width, data = iris)  # create summary with extra object arguments using `conflate` (conflated_summary <- conflate(summary(x))) #> conflate function for summary #>  args: x, object.args  purrr::map(   list(glm.model, lm.model),   ~ conflated_summary(.,     lm.correlation = TRUE, glm.correlation = TRUE,     glm.symbolic.cor = TRUE   ) ) #> [[1]] #>  #> Call: #> glm(formula = Sepal.Length ~ Sepal.Width, data = iris) #>  #> Deviance Residuals:  #>     Min       1Q   Median       3Q      Max   #> -1.5561  -0.6333  -0.1120   0.5579   2.2226   #>  #> Coefficients: #>             Estimate Std. Error t value Pr(>|t|)     #> (Intercept)   6.5262     0.4789   13.63   <2e-16 *** #> Sepal.Width  -0.2234     0.1551   -1.44    0.152     #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> (Dispersion parameter for gaussian family taken to be 0.6807844) #>  #>     Null deviance: 102.17  on 149  degrees of freedom #> Residual deviance: 100.76  on 148  degrees of freedom #> AIC: 371.99 #>  #> Number of Fisher Scoring iterations: 2 #>  #> Correlation of Coefficients: #>                 #> (Intercept) 1   #> Sepal.Width B 1 #> attr(,\"legend\") #> [1] 0 ‘ ’ 0.3 ‘.’ 0.6 ‘,’ 0.8 ‘+’ 0.9 ‘*’ 0.95 ‘B’ 1 #>  #>  #> [[2]] #>  #> Call: #> lm(formula = Sepal.Length ~ Sepal.Width, data = iris) #>  #> Residuals: #>     Min      1Q  Median      3Q     Max  #> -1.5561 -0.6333 -0.1120  0.5579  2.2226  #>  #> Coefficients: #>             Estimate Std. Error t value Pr(>|t|)     #> (Intercept)   6.5262     0.4789   13.63   <2e-16 *** #> Sepal.Width  -0.2234     0.1551   -1.44    0.152     #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> Residual standard error: 0.8251 on 148 degrees of freedom #> Multiple R-squared:  0.01382,\tAdjusted R-squared:  0.007159  #> F-statistic: 2.074 on 1 and 148 DF,  p-value: 0.1519 #>  #> Correlation of Coefficients: #>             (Intercept) #> Sepal.Width -0.99       #>  #>   # alternatively, you could supply `correlation` as a default in conflate itself (conflated_summary <- conflate(summary(x, correlation = TRUE))) #> conflate function for summary #>  args: x, correlation = TRUE, object.args  purrr::map(   list(glm.model, lm.model),   ~ conflated_summary(., lm.symbolic.cor = TRUE) ) #> [[1]] #>  #> Call: #> glm(formula = Sepal.Length ~ Sepal.Width, data = iris) #>  #> Deviance Residuals:  #>     Min       1Q   Median       3Q      Max   #> -1.5561  -0.6333  -0.1120   0.5579   2.2226   #>  #> Coefficients: #>             Estimate Std. Error t value Pr(>|t|)     #> (Intercept)   6.5262     0.4789   13.63   <2e-16 *** #> Sepal.Width  -0.2234     0.1551   -1.44    0.152     #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> (Dispersion parameter for gaussian family taken to be 0.6807844) #>  #>     Null deviance: 102.17  on 149  degrees of freedom #> Residual deviance: 100.76  on 148  degrees of freedom #> AIC: 371.99 #>  #> Number of Fisher Scoring iterations: 2 #>  #> Correlation of Coefficients: #>             (Intercept) #> Sepal.Width -0.99       #>  #>  #> [[2]] #>  #> Call: #> lm(formula = Sepal.Length ~ Sepal.Width, data = iris) #>  #> Residuals: #>     Min      1Q  Median      3Q     Max  #> -1.5561 -0.6333 -0.1120  0.5579  2.2226  #>  #> Coefficients: #>             Estimate Std. Error t value Pr(>|t|)     #> (Intercept)   6.5262     0.4789   13.63   <2e-16 *** #> Sepal.Width  -0.2234     0.1551   -1.44    0.152     #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> Residual standard error: 0.8251 on 148 degrees of freedom #> Multiple R-squared:  0.01382,\tAdjusted R-squared:  0.007159  #> F-statistic: 2.074 on 1 and 148 DF,  p-value: 0.1519 #>  #> Correlation of Coefficients: #>                 #> (Intercept) 1   #> Sepal.Width B 1 #> attr(,\"legend\") #> [1] 0 ‘ ’ 0.3 ‘.’ 0.6 ‘,’ 0.8 ‘+’ 0.9 ‘*’ 0.95 ‘B’ 1 #>  #>"},{"path":"/reference/conserve.html","id":null,"dir":"Reference","previous_headings":"","what":"Maintain name as binding in local environment — conserve","title":"Maintain name as binding in local environment — conserve","text":"conserve allows third argument bound name given second argument local environment, returning first argument. sort side-effect function binds caller environment.","code":""},{"path":"/reference/conserve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Maintain name as binding in local environment — conserve","text":"","code":"conserve(obj, name, value)"},{"path":"/reference/conserve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Maintain name as binding in local environment — conserve","text":"obj [R object] object, specifically data. name [symbol string] name value bound locally. value [R object] value name.","code":""},{"path":"/reference/conserve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Maintain name as binding in local environment — conserve","text":"obj . side effect local binding value specified name.","code":""},{"path":"/reference/conserve.html","id":"conserving-intermediate-objects","dir":"Reference","previous_headings":"","what":"Conserving Intermediate Objects","title":"Maintain name as binding in local environment — conserve","text":"best use conserve one needs keep object long sequence commands used later sequence (mostly pipes). essential provide local context (e.g. using local inside functions) avoid altering global environment, since internally, rlang::local_bindings used. conserve function used \"convey\" pipe bind intermediary objects provided symbols. Exported rare occasion may useful . One can also specifically set conserve(name, value) directives among convey instructions. value argument can specified magrittr pipe context. , automatic data masking well . symbol representing original object.","code":""},{"path":[]},{"path":"/reference/construct-operator.html","id":null,"dir":"Reference","previous_headings":"","what":"Piping environment for transforming data into new data format — %$>%","title":"Piping environment for transforming data into new data format — %$>%","text":"%$>% construct operator allows taking apart elements data build new data type quickly. done data masking access original object . pronoun magrittr. line component new data. line assignment, new component name assigned variable name, otherwise, position determined many previous variables assigned. See examples.","code":""},{"path":"/reference/construct-operator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Piping environment for transforming data into new data format — %$>%","text":"","code":"data %$>% code"},{"path":"/reference/construct-operator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Piping environment for transforming data into new data format — %$>%","text":"data [R object] object, specifically data results previous pipes. code [individual bindings R commands] Instructions wrapped curly braces encapsualte context pipe.","code":""},{"path":"/reference/construct-operator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Piping environment for transforming data into new data format — %$>%","text":"list fields specified assignments inside code.","code":""},{"path":[]},{"path":"/reference/construct-operator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Piping environment for transforming data into new data format — %$>%","text":"","code":"# use the pipe to build data in steps: testdf <- tibble::tribble(   ~x, ~y,   3, 2,   5, 9,   12, 8 ) testdf %$>% {   minx <- min(x)   miny <- min(y)   minxy <- min(minx, miny) } #> $minx #> [1] 3 #>  #> $miny #> [1] 2 #>  #> $minxy #> [1] 2 #>   # use the dot pronoun to refer to the entire data c(5, 9, 10) %$>% {   min <- min(.)   max <- max(.)   whole <- . } #> $min #> [1] 5 #>  #> $max #> [1] 10 #>  #> $whole #> [1]  5  9 10 #>   # use curly braces for multiline instructions testdf %$>% {   minxy <- {     minx <- min(x)     miny <- min(y)     min(minx, miny)   }   maxall <- max(.)   minall <- min(.) } #> $minxy #> [1] 2 #>  #> $maxall #> [1] 12 #>  #> $minall #> [1] 2 #>   # Unnamed instructions can only be accessed by position val <- testdf %$>% {   min(x)   xval <- x   min(y) } val$xval #> [1]  3  5 12 val[[1]] #> [1] 3 val[[3]] #> [1] 2"},{"path":"/reference/convey-operator.html","id":null,"dir":"Reference","previous_headings":"","what":"Piping environment for brevity and coalescence — %->%","title":"Piping environment for brevity and coalescence — %->%","text":"%->% convey operator allows omission %>% pipe operator environment well setting local bindings can used later stages sequence functions.","code":""},{"path":"/reference/convey-operator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Piping environment for brevity and coalescence — %->%","text":"","code":"obj %->% code"},{"path":"/reference/convey-operator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Piping environment for brevity and coalescence — %->%","text":"obj [R object] object, specifically data results previous pipes. code [individual bindings R commands] Instructions wrapped curly braces encapsualte context pipe.","code":""},{"path":"/reference/convey-operator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Piping environment for brevity and coalescence — %->%","text":"object resulting transformations applied code.","code":""},{"path":"/reference/convey-operator.html","id":"writing-shorter-more-integrated-pipes","dir":"Reference","previous_headings":"","what":"Writing Shorter, More Integrated Pipes","title":"Piping environment for brevity and coalescence — %->%","text":"Piping usually one single context, therefore extra pipe operators end instruction seems extraneous. Nevertheless, one may need record result pipe certain stage, later build whole object simpler modifications original object. Something simple pipe operator handle. Therefore, solution define context two cases, perform operations therein, return desired result. \"convey\" operator .","code":""},{"path":"/reference/convey-operator.html","id":"usage-of-the-convey-operator","dir":"Reference","previous_headings":"","what":"Usage of the convey Operator","title":"Piping environment for brevity and coalescence — %->%","text":"object part can single object result previous piping operations. instructions exactly command sequentially passed next via conventional magrittr pipe. time function instruction followed binding, respective symbol bound specified computation. See examples conserve.","code":"object %->% code"},{"path":[]},{"path":"/reference/convey-operator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Piping environment for brevity and coalescence — %->%","text":"","code":"# use piping context instead of sequentially using the `magrittr` pipe: testdf <- tibble::tribble(   ~x, ~y,   1, 2,   5, 9,   12, 8 ) mydf <- testdf %->% {   dplyr::mutate(x2 = x^2)   dplyr::mutate(x6 = x2^3) } all.equal(   mydf,   testdf %>% dplyr::mutate(x2 = x^2) %>% dplyr::mutate(x6 = x2^3) ) #> [1] TRUE   # bind intermediate values for later use mydf2 <- testdf %->% {   dplyr::mutate(x2 = x^2)   somedf <- .   dplyr::mutate(x6 = (somedf$x2)^3) } all.equal(mydf, mydf2) #> [1] TRUE ## intermediate values do not remain after the pipe is done as.character(tryCatch(somedf, error = function(e) e)) #> [1] \"Error in doTryCatch(return(expr), name, parentenv, handler): object 'somedf' not found\\n\"  # automatic data masking in assignment mydf <- testdf %->% {   dplyr::mutate(x2 = x^2)   colx2xy <- x2 + x + y   dplyr::mutate(x2xyval = colx2xy)   dplyr::mutate(x2xy = x2 + x + y) } all.equal(mydf$x2xyval, mydf$x2xy) #> [1] TRUE"},{"path":"/reference/convoke.html","id":null,"dir":"Reference","previous_headings":"","what":"Unify function interfaces — convoke","title":"Unify function interfaces — convoke","text":"convoke unifies functions along single specification using statements function argument transformations needed. result single function whose interface can changed simply changing respective argument generated function.","code":""},{"path":"/reference/convoke.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unify function interfaces — convoke","text":"","code":"convoke(argslist, ...)"},{"path":"/reference/convoke.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unify function interfaces — convoke","text":"argslist [list] desired unifying arguments. list call. ... [function] various specifications function argument transformations.","code":""},{"path":"/reference/convoke.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unify function interfaces — convoke","text":"Function additional class convoke arguments evaluate argument useful debugging purposes. Extra arguments can passed format interface.arg.","code":"convoke_func(specified_args, interface, ..., evaluate = TRUE)"},{"path":[]},{"path":"/reference/convoke.html","id":"specifying-the-unifying-interface","dir":"Reference","previous_headings":"","what":"Specifying the unifying interface","title":"Unify function interfaces — convoke","text":"unifying interface needs specified arglist new function","code":"list(arg1 = default1, arg2 = default2, etc.)"},{"path":"/reference/convoke.html","id":"specifying-function-argument-transformations","dir":"Reference","previous_headings":"","what":"Specifying function argument transformations","title":"Unify function interfaces — convoke","text":"Transformations follows function specification format Essentially, pass function take arguments unified function.","code":"func1(func1arg1 = transformed_arg1, func1arg2 = transformed_arg2)"},{"path":"/reference/convoke.html","id":"composing-functions","dir":"Reference","previous_headings":"","what":"Composing functions","title":"Unify function interfaces — convoke","text":"also possible progressively add functions convoke function simply adding convoke function new specifications:","code":"convoke_func + ~func_spec"},{"path":[]},{"path":"/reference/convoke.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unify function interfaces — convoke","text":"","code":"# unifying functions with swapped arguments foo <- function(a1, b1) {   a1 / b1 } bar <- function(b2, a2) {   a2 / b2 } convoked <- convoke(   list(a, b),   foo(a1 = a, b1 = b),   bar(b2 = b, a2 = a) ) c(convoked(9, 5), bar(5, 9)) #> [1] 1.8 1.8 c(convoked(9, 5, interface = \"bar\"), foo(9, 5)) #> [1] 1.8 1.8  # supplying optional arguments foo <- function(a1, b1, round = FALSE) {   if (round) round(a1 / b1) else a1 / b1 } bar <- function(b2, a2) {   a2 / b2 } convoked <- convoke(   list(a, b),   foo(a1 = a, b1 = b),   bar(b2 = b, a2 = a) ) c(convoked(9, 5, foo.round = FALSE), bar(5, 9)) #> [1] 1.8 1.8 c(convoked(9, 5, foo.round = TRUE), round(bar(5, 9))) #> [1] 2 2  # TODO fix and show this for three sequences # adding further functions later foo <- function(a1, b1) {   a1 / b1 } bar <- function(b2, a2) {   a2 / b2 } (convoked <- convoke(list(a, b), foo(a1 = a, b1 = b))) #> convoke function #>   interfaces: foo() #>   args: a, b, interface = foo, interface.args (convoked <- convoked + ~ bar(b2 = b, a2 = a)) #> convoke function #>   interfaces: foo(), bar() #>   args: a, b, interface = foo, interface.args c(convoked(9, 5, interface = \"bar\"), foo(5, 9)) #> [1] 1.8000000 0.5555556"},{"path":"/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details. See magrittr::%!>% details.","code":""},{"path":"/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs  lhs %!>% rhs"},{"path":"/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs). result eagerly calling rhs(lhs).","code":""},{"path":"/reference/pipem-operator.html","id":null,"dir":"Reference","previous_headings":"","what":"Piping environment for brevity and coalescence — %->%","title":"Piping environment for brevity and coalescence — %->%","text":"%->% pipem operator allows omission %>% pipe operator environment well setting local bindings can used later stages sequence functions.","code":""},{"path":"/reference/pipem-operator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Piping environment for brevity and coalescence — %->%","text":"","code":"obj %->% instructions"},{"path":"/reference/pipem-operator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Piping environment for brevity and coalescence — %->%","text":"obj [R object] object, specifically data results previous pipes. instructions [individual bindings R commands] Instructions wrapped curly braces encapsualte context pipe.","code":""},{"path":"/reference/pipem-operator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Piping environment for brevity and coalescence — %->%","text":"object resulting transformations applied instructions.","code":""},{"path":"/reference/pipem-operator.html","id":"writing-shorter-more-integrated-pipes","dir":"Reference","previous_headings":"","what":"Writing Shorter, More Integrated Pipes","title":"Piping environment for brevity and coalescence — %->%","text":"Piping usually one single context, therefore extra pipe operators end instruction seems extraneous. Nevertheless, one may need record result pipe certain stage, later build whole object simpler modifications original object. Something simple pipe operator handle. Therefore, solution define context two cases, perform operations therein, return desired result. \"pipem\" operator .","code":""},{"path":"/reference/pipem-operator.html","id":"usage-of-the-pipem-operator","dir":"Reference","previous_headings":"","what":"Usage of the pipem Operator","title":"Piping environment for brevity and coalescence — %->%","text":"object part can single object result previous piping operations. instructions exactly command sequentially passed next via conventional magrittr pipe. time function instruction followed binding, respective symbol bound specified computation. See examples conserve.","code":"object %->% {instructions}"},{"path":[]},{"path":"/reference/pipem-operator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Piping environment for brevity and coalescence — %->%","text":"","code":"# use piping context instead of sequentially using the `magrittr` pipe: testdf <- tibble::tribble(   ~x, ~y,   1, 2,   5, 9,   12, 8 ) mydf <- testdf %->% {   dplyr::mutate(x2 = x^2)   dplyr::mutate(x6 = x2^3) } all.equal(   mydf,   testdf %>% dplyr::mutate(x2 = x^2) %>% dplyr::mutate(x6 = x2^3) ) #> [1] TRUE   # bind intermediate values for later use mydf2 <- testdf %->% {   dplyr::mutate(x2 = x^2)   somedf <- .   dplyr::mutate(x6 = (somedf$x2)^3) } all.equal(mydf, mydf2) #> [1] TRUE ## intermediate values do not remain after the pipe is done as.character(tryCatch(somedf, error = function(e) e)) #> [1] \"Error in doTryCatch(return(expr), name, parentenv, handler): object 'somedf' not found\\n\"  # automatic data masking in assignment mydf <- testdf %->% {   dplyr::mutate(x2 = x^2)   colx2xy <- x2 + x + y   dplyr::mutate(x2xyval = colx2xy)   dplyr::mutate(x2xy = x2 + x + y) } all.equal(mydf$x2xyval, mydf$x2xy) #> [1] TRUE"},{"path":"/reference/to-operator.html","id":null,"dir":"Reference","previous_headings":"","what":"Pass object to multiple directives — %to%","title":"Pass object to multiple directives — %to%","text":"%% allows single object passed multiple commands, results returned single dataframe.","code":""},{"path":"/reference/to-operator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pass object to multiple directives — %to%","text":"","code":"obj %to% blocks"},{"path":"/reference/to-operator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pass object to multiple directives — %to%","text":"obj Object passed multiple instructions blocks formula-like instructions wrapped pair braces {}.","code":""},{"path":"/reference/to-operator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pass object to multiple directives — %to%","text":"Dataframe column names formula LHS values, single row containing results column's respective instructions.","code":""},{"path":"/reference/to-operator.html","id":"passing-object-to-multiple-instructions-","dir":"Reference","previous_headings":"","what":"Passing object to multiple instructions:","title":"Pass object to multiple directives — %to%","text":"syntax use purpose object LHS %% operator, wrap instructions braces pair effectively acts multiple lines regular R code. However, line needs named, formula syntax fashion: right side formula specified similar instructions purrr:map , , ., .x syntax. multiple lines needed instruction, one can simply wrap yet another braces pair.","code":"obj %to% {  inst1 ~ inst1expressions(.)  inst2 ~ inst2expressions(.) }"},{"path":[]},{"path":"/reference/to-operator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pass object to multiple directives — %to%","text":"","code":"# returning multiple analysis on same object testvec <- c(1, 2, 3, 7) testvec %to% {   mean ~ mean(.)   sd ~ sd(.) } #> # A tibble: 1 × 2 #>    mean    sd #>   <dbl> <dbl> #> 1  3.25  2.63  # use nested braces for longer expressions testvec %to% {   mean2 ~ {     x <- . + 3     mean(x * .)   }   sd ~ sd(.) } #> # A tibble: 1 × 2 #>   mean2    sd #>   <dbl> <dbl> #> 1  25.5  2.63  # vector results are stored as lists in the dataframe testvec %to% {   itself ~ .   itsmean ~ mean(.) } #> # A tibble: 1 × 2 #>   itself    itsmean #>   <I<list>>   <dbl> #> 1 <dbl [4]>    3.25  testvec %to% {   itself ~ .   itsextra ~ c(2, .) } #> # A tibble: 1 × 2 #>   itself    itsextra  #>   <I<list>> <I<list>> #> 1 <dbl [4]> <dbl [5]>"},{"path":"/news/index.html","id":"tyecon-023","dir":"Changelog","previous_headings":"","what":"tyecon 0.2.3","title":"tyecon 0.2.3","text":"Add construct pipe","code":""},{"path":"/news/index.html","id":"tyecon-022","dir":"Changelog","previous_headings":"","what":"tyecon 0.2.2","title":"tyecon 0.2.2","text":"Add convey operator conciser powerful piping statements Remove formula specification postprocessing convoke Use argslist instead function convoke","code":""},{"path":"/news/index.html","id":"tyecon-021","dir":"Changelog","previous_headings":"","what":"tyecon 0.2.1","title":"tyecon 0.2.1","text":"Add conflate function use generic methods Change unifying function name convoke Change interface use anonymous functions Fix bug environment hierarchy (commit 83d5e8dce01b9b7eb401e5c122bb999cc04179ec)","code":""},{"path":"/news/index.html","id":"tyecon-020","dir":"Changelog","previous_headings":"","what":"tyecon 0.2.0","title":"tyecon 0.2.0","text":"Add package site Improve readme vignettes","code":""},{"path":"/news/index.html","id":"tyecon-010","dir":"Changelog","previous_headings":"","what":"tyecon 0.1.0","title":"tyecon 0.1.0","text":"convoke %% work elementary cases. Pretty printing convoke objects. Possibility composing functions existing convoke object (via + operator).","code":""},{"path":"/news/index.html","id":"tyecon-0009000","dir":"Changelog","previous_headings":"","what":"tyecon 0.0.0.9000","title":"tyecon 0.0.0.9000","text":"Added NEWS.md file track changes package.","code":""}]
